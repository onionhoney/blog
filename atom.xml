<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stochastic Thoughts</title>
  
  <subtitle>A programming blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://onionhoney.github.io/"/>
  <updated>2017-10-17T06:44:21.000Z</updated>
  <id>http://onionhoney.github.io/</id>
  
  <author>
    <name>Jeffrey Zhouheng Sun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Case Study of Fun Greedy Problems</title>
    <link href="http://onionhoney.github.io/2017/10/2D-segment-Tree/"/>
    <id>http://onionhoney.github.io/2017/10/2D-segment-Tree/</id>
    <published>2017-10-17T05:58:43.000Z</published>
    <updated>2017-10-17T06:44:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>The importance of greedy problems can never be overstated.They not only produce most of the awesome &quot;aha&quot; moments in competitive coding, but also trains good intuition as well as proof skills. Over the summer I have encountered a few of these awesome greedy problems, which I shall summarize below:</p><h3>1. Maximum minimum adjacent gap</h3><blockquote><p>Given a finite integer sequence , find a permutation that would maximize the minimum adjacent gap. For instance, the min gap of [1, 5, 2] is 3, because min(|1 - 5|, |5 - 2|) = 3.</p></blockquote><p>The gist of a greedy proof is that &quot;It might look sketchy, but I can show you that none better exists.&quot; A common way to develop an idea is to brainstorm any &quot;suboptimal&quot; greedy solution that comes to mind, and refute them with counterexamples, until you found something which you cannot easily refute with example.</p><p>For this problem, I first considered binary search (which is somewhat related to greedy because both methods reduce the search space with very crude assumptions (greedy is to &quot;choose the best xxx&quot;, binary search is to &quot;know that if l and r satisfy A, then all of [l..r] satisfy A&quot;. ))</p><p>Back to the binary search strategy. So what if we binary-search on the min gap, and use that to greedily pick elements one by one from the sequence? The issue is, we can't really decide whether to go up or down for the next element. Okay, so let's fix it by sorting it first.Now, where do we start? My intuition was the smallest/largest elements are too wasteful to be placed in the head or tail, because then they can only &quot;benefit&quot; one neighbor with their potential for large gaps. Therefore i zeroed in on the median, for it produces the smallest average gap with a random other element, and that we should alternate between the smaller half and the larger half, because well, one half could be really crowded to pick consecutives from. For instance, something like 1 10 20 30 100 101 102 103 would be disastrous.</p><p>Time to test our strategy. Will it always work?</p><p>(To be continued)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;The importance of greedy problems can never be overstated.
They not only produce most of the awesome &amp;quot;aha&amp;quot; moments in competiti
      
    
    </summary>
    
    
  </entry>
  
</feed>
